package actionhelp

import (
	"encoding/json"
	"fmt"
	"sort"
	"strings"
	"time"

	"flowk/internal/actions/registry"
)

type FieldDocumentation struct {
	Name        string `json:"name"`
	Description string `json:"description,omitempty"`
}

type OperationDocumentation struct {
	Name     string               `json:"name"`
	Required []FieldDocumentation `json:"required"`
	Note     string               `json:"note,omitempty"`
	Example  string               `json:"example,omitempty"`
}

type AllowedValue struct {
	Field  string   `json:"field"`
	Values []string `json:"values"`
}

type ActionDocumentation struct {
	Name          string                   `json:"name"`
	Required      []FieldDocumentation     `json:"required"`
	Optional      []FieldDocumentation     `json:"optional"`
	Operations    []OperationDocumentation `json:"operations,omitempty"`
	AllowedValues []AllowedValue           `json:"allowedValues,omitempty"`
	Example       string                   `json:"example,omitempty"`
	HelpMarkdown  string                   `json:"helpMarkdown,omitempty"`
}

type GuideDocument struct {
	Primer      string                `json:"primer"`
	GeneratedAt time.Time             `json:"generatedAt"`
	Actions     []ActionDocumentation `json:"actions"`
}

// BuildDocumentation returns a structured representation of the action schema,
// including required/optional fields, operations and an autogenerated example.
func BuildDocumentation(actionName string) (ActionDocumentation, error) {
	summary, err := loadActionSchemaSummary(actionName)
	if err != nil {
		return ActionDocumentation{}, err
	}

	return actionDocumentationFromSummary(summary), nil
}

// BuildAllDocumentation gathers documentation for every registered action.
func BuildAllDocumentation() ([]ActionDocumentation, error) {
	names := registry.Names()
	docs := make([]ActionDocumentation, 0, len(names))

	for _, name := range names {
		doc, err := BuildDocumentation(name)
		if err != nil {
			return nil, err
		}
		docs = append(docs, doc)
	}

	return docs, nil
}

// BuildGuide assembles a complete guide with all actions and a primer that
// explains how to structure FlowK definitions for AI generators.
func BuildGuide() (GuideDocument, error) {
	actions, err := BuildAllDocumentation()
	if err != nil {
		return GuideDocument{}, err
	}

	return GuideDocument{
		Primer:      defaultPrimer,
		GeneratedAt: time.Now().UTC(),
		Actions:     actions,
	}, nil
}

// FormatGuideMarkdown renders the guide as Markdown so it can be downloaded or
// consumed directly by language models.
func FormatGuideMarkdown(guide GuideDocument) string {
	var b strings.Builder

	b.WriteString("# FlowK: action and operation catalog\n\n")

	if primer := strings.TrimSpace(guide.Primer); primer != "" {
		b.WriteString(primer)
		if !strings.HasSuffix(primer, "\n") {
			b.WriteString("\n")
		}
		b.WriteString("\n")
	}

	for _, action := range guide.Actions {
		b.WriteString(fmt.Sprintf("## %s\n\n", strings.ToUpper(action.Name)))

		if len(action.Required) > 0 {
			b.WriteString("**Required fields**\n\n")
			for _, field := range action.Required {
				line := fmt.Sprintf("- `%s`", field.Name)
				if desc := strings.TrimSpace(field.Description); desc != "" {
					line = fmt.Sprintf("%s — %s", line, desc)
				}
				b.WriteString(line + "\n")
			}
			b.WriteString("\n")
		}

		if len(action.Optional) > 0 {
			b.WriteString("**Optional fields**\n\n")
			for _, field := range action.Optional {
				line := fmt.Sprintf("- `%s`", field.Name)
				if desc := strings.TrimSpace(field.Description); desc != "" {
					line = fmt.Sprintf("%s — %s", line, desc)
				}
				b.WriteString(line + "\n")
			}
			b.WriteString("\n")
		}

		if len(action.AllowedValues) > 0 {
			b.WriteString("**Allowed values**\n\n")
			for _, allowed := range action.AllowedValues {
				if len(allowed.Values) == 0 {
					continue
				}
				b.WriteString(fmt.Sprintf("- `%s`: %s\n", allowed.Field, strings.Join(allowed.Values, ", ")))
			}
			b.WriteString("\n")
		}

		if len(action.Operations) > 0 {
			b.WriteString("**Available operations**\n\n")
			for _, op := range action.Operations {
				title := strings.TrimSpace(op.Name)
				if title == "" {
					title = "Operation"
				}
				b.WriteString(fmt.Sprintf("- **%s**\n", title))
				for _, field := range op.Required {
					line := fmt.Sprintf("  - `%s`", field.Name)
					if desc := strings.TrimSpace(field.Description); desc != "" {
						line = fmt.Sprintf("%s — %s", line, desc)
					}
					b.WriteString(line + "\n")
				}
				if note := strings.TrimSpace(op.Note); note != "" {
					b.WriteString(fmt.Sprintf("  - Note: %s\n", note))
				}
				if example := strings.TrimSpace(op.Example); example != "" {
					b.WriteString("  - Example:\n\n")
					b.WriteString("```json\n")
					b.WriteString(example + "\n")
					b.WriteString("```\n\n")
				}
			}
			b.WriteString("\n")
		} else {
			b.WriteString("_This action does not declare specific operations._\n\n")
		}

		if example := strings.TrimSpace(action.Example); example != "" {
			b.WriteString("**Task example**\n\n")
			b.WriteString("```json\n")
			b.WriteString(example + "\n")
			b.WriteString("```\n\n")
		}

		if help := strings.TrimSpace(action.HelpMarkdown); help != "" {
			b.WriteString("**Extended documentation**\n\n")
			b.WriteString(normalizeHelpMarkdown(help))
			if !strings.HasSuffix(help, "\n") {
				b.WriteString("\n")
			}
			b.WriteString("\n")
		}
	}

	return b.String()
}

func normalizeHelpMarkdown(content string) string {
	lines := strings.Split(content, "\n")
	for i, line := range lines {
		if !strings.HasPrefix(line, "#") {
			continue
		}
		count := 0
		for count < len(line) && line[count] == '#' {
			count++
		}
		if count == 0 {
			continue
		}
		newCount := count + 2
		if newCount > 6 {
			newCount = 6
		}
		lines[i] = strings.Repeat("#", newCount) + line[count:]
	}
	return strings.Join(lines, "\n")
}

func actionDocumentationFromSummary(summary actionSchemaSummary) ActionDocumentation {
	doc := ActionDocumentation{
		Name:          summary.ActionName,
		Required:      convertFieldSummaries(summary.Required),
		Optional:      convertFieldSummaries(summary.Optional),
		Operations:    buildOperationDocs(summary.ConditionalGroups),
		AllowedValues: buildAllowedValues(summary),
		Example:       buildActionExample(summary),
		HelpMarkdown:  findActionHelpMarkdown(summary.ActionName),
	}

	return doc
}

func convertFieldSummaries(fields []fieldSummary) []FieldDocumentation {
	docs := make([]FieldDocumentation, 0, len(fields))
	for _, field := range fields {
		docs = append(docs, FieldDocumentation{
			Name:        field.Name,
			Description: field.Description,
		})
	}
	return docs
}

func buildOperationDocs(groups []conditionalRequirementGroup) []OperationDocumentation {
	if len(groups) == 0 {
		return nil
	}

	docs := make([]OperationDocumentation, 0, len(groups))
	for _, group := range groups {
		name := strings.TrimSpace(group.Title)
		if op, ok := operationNameFromOverrides(group.ExampleOverrides); ok {
			name = op
		}

		var example string
		if len(group.ExampleOverrides) > 0 {
			if data, err := json.MarshalIndent(group.ExampleOverrides, "", "  "); err == nil {
				example = string(data)
			}
		}

		docs = append(docs, OperationDocumentation{
			Name:     name,
			Required: convertFieldSummaries(group.Required),
			Note:     strings.TrimSpace(group.Note),
			Example:  example,
		})
	}
	return docs
}

func operationNameFromOverrides(overrides map[string]any) (string, bool) {
	if len(overrides) == 0 {
		return "", false
	}

	raw, ok := overrides["operation"]
	if !ok {
		return "", false
	}

	name, ok := raw.(string)
	if !ok {
		return "", false
	}

	trimmed := strings.TrimSpace(name)
	if trimmed == "" {
		return "", false
	}
	if trimmed == "<operation>" {
		return "any operation (valor dinámico)", true
	}

	return trimmed, true
}

func buildAllowedValues(summary actionSchemaSummary) []AllowedValue {
	values := make([]AllowedValue, 0)

	for name, property := range summary.Properties {
		allowed := collectAllowedValues(property)
		if len(allowed) == 0 {
			continue
		}
		values = append(values, AllowedValue{
			Field:  name,
			Values: allowed,
		})
	}

	sort.Slice(values, func(i, j int) bool {
		return values[i].Field < values[j].Field
	})

	return values
}

func collectAllowedValues(property map[string]any) []string {
	if property == nil {
		return nil
	}

	candidates := make([]string, 0)

	if constValue, ok := stringValue(property["const"]); ok {
		if trimmed := strings.TrimSpace(constValue); trimmed != "" {
			candidates = append(candidates, trimmed)
		}
	}

	for _, enumValue := range stringSlice(property["enum"]) {
		if trimmed := strings.TrimSpace(enumValue); trimmed != "" {
			candidates = append(candidates, trimmed)
		}
	}

	return uniqueStrings(candidates)
}

func uniqueStrings(values []string) []string {
	seen := make(map[string]struct{}, len(values))
	deduped := make([]string, 0, len(values))

	for _, value := range values {
		if _, ok := seen[value]; ok {
			continue
		}
		seen[value] = struct{}{}
		deduped = append(deduped, value)
	}

	return deduped
}

const defaultPrimer = `Each FlowK flow is a JSON object with this structure:

Example:

{
  "id": "payments.flow",
  "description": "Processes payments and sends notifications",
  "imports": ["./subflows/payment_gateway.json", "./subflows/notifications.json"],
  "tasks": [ ... ],
  "on_error_flow": "cleanup.flow",
  "finally_flow": "reporting.flow",
  "finally_task": "notify.finished"
}

Root fields:

- "id": required unique flow identifier.
- "description": required plain-text summary.
- "imports": optional list of additional JSON flow files expanded before execution (resolved relative to the main flow file). Imported flows must each define their own "id". Imported tasks are prepended in import order and keep their flow id for routing and logging.
- "tasks": required ordered array of tasks.
- "on_error_flow": optional flow id to run immediately after a task failure.
- "finally_flow": optional flow id to run after the main flow finishes (success or failure).
- "finally_task": optional task id to run after the main flow finishes (success or failure).

Task basics:

- Every task includes "id" and "action". "description" is optional but strongly recommended.
- Use "operation" only for actions that declare multiple operations. Omit it for actions without operations.
- Some control actions (e.g., "PARALLEL", "FOR") include nested "tasks" arrays; nested tasks follow the same shape.

Subflows:

- A "subflow" is another flow JSON file referenced in "imports".
- Flow ids must be unique across the main flow and all imports.
- Use "on_error_flow" and "finally_flow" to target a specific imported flow by id.

When to use "operation":

- Actions that support multiple modes (for example, "KUBERNETES" or "DB_CASSANDRA_OPERATION") use the "operation" field to select the specific operation. Use the uppercase values listed below.
- If an action does not declare operations, omit the "operation" field.

Best practices for generating flows automatically:

- Keep "id" values in lowercase or snake_case and make them unique across the flow.
- Always include "description" so human operators understand each step's purpose.
- Reuse variables with the "VARIABLES" action and reference them with the ${variable} syntax.
- Choose the correct action and review its required and optional fields in the list below. Use the available operations to build the right payload.
- Preserve task order; FlowK executes tasks sequentially unless a control action (e.g., "EVALUATE" with "gototask" or "exit") dictates otherwise.
- Validate flows against the JSON schema (values.schema.json) before execution to catch type errors or missing fields.`
